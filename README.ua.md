**Доповідь підготував**:  
студент 2-го курсу, групи ІМ-21 *Сірик Максим* [Email](mailto:erotourtes@gmail.com), [Telegram](https://t.me/mabooled)

**Керівник**  
доцент кафедри ОТ ФІОТ, к.т.н., доцент *Андрій БОЛДАК*  

[НТУУ "КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ імені ІГОРЯ СІКОРСЬКОГО](https://kpi.ua/)  
[Факультет інформатики та обчислювальної техніки](https://fiot.kpi.ua/)  
[Кафедра обчислювальної техніки](https://comsys.kpi.ua/)  
Київ

> Примітка: цей текст був перекладений автоматично. Хоч я підкорегував переклад, все ж міг щось пропустити, тому краще читати в оригінальному `README.md`


## Продуктивність в SQL (MySQL)
Спочатку нам потрібно створити базу даних і заповнити її даними. Виконайте ці кроки:
1. перейдіть до `sql/schema.sql`
2. виконайте скрипт у вашій базі даних
3. перейдіть до `src/`
4. додайте `.local.env` із вмістом файлу `.env`
5. виконайте `python main.py`, щоб заповнити базу даних випадковими даними (ви можете змінити кількість рядків у файлі `main.py`)
> встановіть залежності Python за допомогою `pip install -r requirements.txt`

База даних готова до використання. Тепер ви можете виконувати запити.
![зображення](./public/state.png)

## Індекси
Давайте почнемо з визначення.
Індекс - це структура даних, яка покращує швидкість операцій отримання даних з таблиці бази даних за рахунок додаткового запису та простору для збереження структури даних індексу.

Індекси використовуються для швидкого знаходження даних без необхідності пошуку кожного рядка в таблиці бази даних при кожному доступі до таблиці бази даних. Індекси можуть бути створені з використанням одного або декількох стовпців таблиці бази даних, надаючи підставу як для швидких випадкових пошуків, так і для ефективного доступу до впорядкованих записів.

### Індекси в MySQL
У MySQL існує кілька типів індексів:
- Залежно від кількості стовпців
  - Індекси стовпців
  - Складені індекси
  - Індекси повного тексту
- Залежно від призначення
  - Індекс первинного ключа
  - Вторинний індекс
  - Індекс унікальних значень (вторинний індекс із унікальними значеннями)
  - Просторовий індекс (для геометричних типів даних, які НЕ Є NULL)
  - Індекс повного тексту (повнотекстовий пошук)
  - Індекс у зворотньому порядку (ключі зберігаються у зворотньому порядку)

Але як визначити, чи використовується індекс чи ні?
Ми можемо використовувати заяву `EXPLAIN`, щоб отримати інформацію про те, як MySQL виконує запит.
> Примітка: Заяви `DESCRIBE` та `EXPLAIN` є синонімами.

```sql
EXPLAIN SELECT * FROM `users` WHERE `user_id` = 1;
```

Результат запиту має бути наступним чином:
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | NULL | **const** | PRIMARY | PRIMARY | 4 | const | **1** | 100.00 | NULL |


Найважливіші стовпці - type та key.
- Стовпець type показує, як MySQL виконає запит.
- Стовпець key показує, який індекс буде використаний. (у нашому випадку це PRIMARY, оскільки PRIMARY KEY також є індексом!)

> Урок: завжди використовуйте PRIMARY KEY у ваших таблицях та робіть його невеликим.  
  [Докладніше](https://planetscale.com/blog/how-read-mysql-explains)


### Повний скан таблиці

Давайте дізнаємося, чи є `Jesus` у нашій базі даних.
```sql
EXPLAIN SELECT * 
FROM `users` 
WHERE `first_name` = "Jesus";
```
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | NULL | <ins>ALL</ins> | NULL | NULL | NULL | NULL | <ins>9684</ins> | 10.00 | Using where 

Зверніть увагу, що type - ALL, а key - NULL. Це означає, що MySQL буде сканувати всі рядки в таблиці для пошуку відповідних рядків.

---

### Створення індексів

Перед створенням індексів нам потрібно знати, які стовпці ми будемо використовувати в наших запитах. Не сліпо створюйте індекси на кожному стовпці у вашій таблиці.

Перед створенням індексу ви повинні врахувати наступне:

- Індекси зберігаються у пам'яті. Таким чином, чим більше у вас індексів, тим більше пам'яті вам потрібно.
- Індекси оновлюються при кожному вставленні, оновленні та видаленні. Таким чином, чим більше у вас індексів, тим повільнішими будуть ваші запити.
- Індекси можна використовувати лише для стовпців, які використовуються в запиті. Таким чином, якщо у вас є індекс на стовпці name, але ви шукаєте за email, індекс не буде використовуватися.
- Повторювані індекси

Ви можете перевірити наявні індекси за допомогою:

```sql
SHOW INDEXES IN `users`;
```
---

### Індекси стовпців
#### Синтаксис

```sql
-- CREATE INDEX idx_name ON table (field)
CREATE INDEX idx_first_name ON `users` (`first_name`);
```
> Ми можемо використовувати індекс стовпця в заявах WHERE, ORDER BY та GROUP BY; функціях MIN() та MAX().
  [Докладніше](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

#### Приклад

Давайте виконаємо запит знову (з індексом з [синтаксису](#Синтаксис)):

```sql
EXPLAIN SELECT * 
FROM `users` 
WHERE `first_name` = "Jesus";
```

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | NULL | <ins>ref</ins> | idx_user_name | idx_name | 222 | const | <ins>7</ins> | 100.00 | NULL |

Зверніть увагу на стовпці type та key.

Також EXPLAIN показує нам, що взаємодія рядків зменшилася з 9684 до 7 (Оскільки у моїй базі даних є 7 Ісусів)!

---

### Складені індекси

#### Синтаксис
```sql
-- CREATE INDEX idx_name ON table (field1, field2, ..., field16)
CREATE INDEX idx_first_name_second_name ON `users` (`first_name`, `second_name`);
```

#### Приклад

Розглянемо цей запит (з індексом з [синтаксису](#Синтаксис-1)):
```sql
SELECT * FROM `users` WHERE `first_name` = "Jesus" AND `second_name` = "Lowe"
```
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | NULL | **ref** | idx_first_name_second_name | idx_first_name_second_name | 444 | const,const | **1** | 100.00 | NULL |


Однак, якщо ми спробуємо використовувати лише `second_name` у нашому запиті, індекс не буде використаний, оскільки це не є лівим стовпцем у нашому індексі.
Це тому, що індекс побудований на першому стовпці (`first_name`), отже
порядок стовпців у індексі МАЄ значення. Ми можемо уявити це у вигляді таблиці.

| Country | Person |
| --- | --- |
| Ukraine | John; Dan; Marc |
| USA | Kate, Castle, Brown, Obama |

| Person | Country |
| --- | --- |
| John | Ukraine |
| Dan | Ukraine |
| Marc | Ukraine |
| Kate | USA |
| Castle | USA |
| Brown | USA |
| Obama | USA |

Як правило, слід розміщувати найбільш вибірковий стовпець першим (стовпець з найбільшою кількістю унікальних значень),
так що перший стовпець у індексі вибраковує найбільше число рядків. Проте спочатку врахуйте ваші запити.

> У моєму випадку у таблиці більше унікальних значень `first_name` ніж `second_name`, тому я розмістив `first_name` першим.
```sql
SELECT  COUNT(DISTINCT first_name) FROM `users`;
SELECT  COUNT(DISTINCT second_name) FROM `users`;
```
---

### Повнотекстові індекси
#### Синтаксис
```sql
-- CREATE FULLTEXT INDEX idx_name ON table (field1, field2, ..., field16)
CREATE FULLTEXT INDEX idx_content ON `posts` (`content`);

-- MATCH(name, name1) AGAINST("some text -exclude +include 'exact phrase'" IN BOOLEAN MODE)
```

Дізнайтеся більше про режим [Boolean](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html)

#### Приклад

Знайдемо пост, в якому йдеться про 'бізнес'.
```sql
EXPLAIN SELECT * FROM posts
WHERE content LIKE "%business%";
```

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | posts | NULL | **ALL** | NULL | NULL | NULL | NULL | **19705** | 11.11 | Using where |


Давайте дізнаємося вартість запиту:
```sql
EXPLAIN ANALYZE SELECT * FROM posts
WHERE content LIKE "%business%";
```
> Примітка: `ANALYZE` не є частиною заяви `EXPLAIN`. Це окрема заява.

У моєму випадку cost - 2043

Тепер давайте створимо повнотекстовий [індекс](#Синтаксис-2) і знову перевіримо вартість.
```sql
EXPLAIN ANALYZE SELECT * FROM posts
WHERE MATCH(content) AGAINST("business")
```

Вартість зменшилася до 1!

> Примітка: Якщо ми запустимо `AGAINST` ("business money"), він знайде пости, що містять або business, або money, або обидва.

---
#### Висновок

Дуже важливо обережно використовувати індекси.
- Покриваючі індекси (які повністю охоплюють запит) краще, ніж кілька індексів для одного стовпця.
- Важливо писати запити, які використовують індекси.
Наприклад, якщо у вас є запит такий як:

```sql
EXPLAIN SELECT * FROM `users`
WHERE `first_name` = "Jesus" OR `second_name` = "Lowe"
```
MySQL не використовуватиме жоден індекс, однак
якщо ми перепишемо запит так:

```sql
SELECT * FROM `users`
WHERE `first_name` = "Jesus"
UNION
SELECT * FROM `users`
WHERE `second_name` = "Lowe"
```
MySQL використовуватиме індекс.
